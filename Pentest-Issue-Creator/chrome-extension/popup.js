// D·ªØ li·ªáu vulnerabilities t·ª´ Cloudflare Host
let vulnerabilities = [];
let selectedVulnerability = null;

// Configuration
const DEFAULT_HOST_URL = 'https://pentest-issue-creator.ncv.workers.dev/vuln?private=2ysY2PmZ9AgrIu50VDRkRq5SztFJd0lv';
const STORAGE_KEYS = {
  HOST_URL: 'pentest_HOST_URL'
};

// L·∫•y c·∫•u h√¨nh t·ª´ Chrome Storage
async function getStoredConfig() {
  try {
    const result = await chrome.storage.local.get([STORAGE_KEYS.HOST_URL]);
    return {
      hostUrl: result[STORAGE_KEYS.HOST_URL] || DEFAULT_HOST_URL
    };
  } catch (error) {
    console.error('Error getting stored config:', error);
    return { hostUrl: DEFAULT_HOST_URL };
  }
}

// L∆∞u c·∫•u h√¨nh v√†o Chrome Storage
async function saveConfig(hostUrl) {
  try {
    await chrome.storage.local.set({
      [STORAGE_KEYS.HOST_URL]: hostUrl
    });
    return true;
  } catch (error) {
    console.error('Error saving config:', error);
    return false;
  }
}

// Load d·ªØ li·ªáu vulnerabilities t·ª´ Cloudflare Host
async function loadVulnerabilities(showStatus = false) {
  try {
    if (showStatus) {
      updateStatus('ƒêang t·∫£i d·ªØ li·ªáu...');
    }
    
    const config = await getStoredConfig();
    
    const headers = {
      'Content-Type': 'application/json'
    };

    const response = await fetch(config.hostUrl, {
      method: 'GET',
      headers,
      cache: 'no-cache'
    });
    
    // If host returns 401, surface message but do not force modal.
    if (response.status === 401) {
      if (showStatus) {
        updateStatus('L·ªói x√°c th·ª±c (401) khi k·∫øt n·ªëi t·ªõi host');
      }
      return false;
    }
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (data.error) {
      throw new Error(data.message || 'API Error');
    }
    
    vulnerabilities = data;
    console.log('ƒê√£ load vulnerabilities t·ª´ Cloudflare Host:', vulnerabilities.length);
    
    if (showStatus) {
      updateStatus(`ƒê√£ t·∫£i ${vulnerabilities.length} lo·∫°i l·ªói`);
      setTimeout(() => updateStatus(''), 2000);
    }
    
    return true;
  } catch (error) {
    console.error('L·ªói khi load t·ª´ Host:', error);
    if (showStatus) {
      updateStatus(`L·ªói: ${error.message}`);
    }
    return false;
  }
}


function showKeyModal() {
  const modal = document.getElementById('keyModal');
  const hostUrlInput = document.getElementById('hostUrlInput');
  
  // Load current config
  getStoredConfig().then(config => {
    hostUrlInput.value = config.hostUrl;
  });
  
  // Use flex so modal centers and allows scrolling inside the popup
  modal.style.display = 'flex';
  // Slight delay to ensure element is visible before focusing
  setTimeout(() => hostUrlInput.focus(), 50);
}

// ·∫®n modal
function hideKeyModal() {
  const modal = document.getElementById('keyModal');
  modal.style.display = 'none';
}

// C·∫≠p nh·∫≠t status message
function updateStatus(message) {
  const statusEl = document.getElementById('status');
  if (statusEl) {
    statusEl.textContent = message;
  }
}

// C·∫≠p nh·∫≠t preview content
function updatePreview(vuln) {
  if (!vuln) {
    hidePreview();
    return;
  }

  // C·∫≠p nh·∫≠t t√™n issue trong header
  const header = document.querySelector('.preview-section h4');
  if (header) {
    header.textContent = vuln.name || 'UNNAMED';
  }

  // C·∫≠p nh·∫≠t n·ªôi dung preview
  const previewDescription = document.getElementById('previewDescription');
  const previewImpact = document.getElementById('previewImpact');
  const previewReproduce = document.getElementById('previewReproduce');
  const previewSolution = document.getElementById('previewSolution');
  const previewNote = document.getElementById('previewNote');

  if (previewDescription) previewDescription.textContent = vuln.desc || vuln.description || 'Kh√¥ng c√≥ m√¥ t·∫£';
  if (previewImpact) previewImpact.textContent = vuln.impact || 'Kh√¥ng c√≥ th√¥ng tin t√°c ƒë·ªông';
  if (previewReproduce) previewReproduce.textContent = vuln.reprod || vuln.reproduce || 'Kh√¥ng c√≥ h∆∞·ªõng d·∫´n t√°i hi·ªán';
  if (previewSolution) previewSolution.textContent = vuln.solution || 'Kh√¥ng c√≥ gi·∫£i ph√°p';
  if (previewNote) previewNote.textContent = vuln.note || 'Kh√¥ng c√≥ ghi ch√∫';

  // Hi·ªÉn th·ªã n√∫t preview toggle
  document.getElementById('previewToggle').style.display = 'inline-block';
}

// Hi·ªÉn th·ªã preview
function showPreview() {
  document.getElementById('previewSection').style.display = 'block';
  document.getElementById('previewToggle').textContent = '·∫®n preview';
}

// ·∫®n preview
function hidePreview() {
  document.getElementById('previewSection').style.display = 'none';
  document.getElementById('previewToggle').textContent = 'Xem tr∆∞·ªõc n·ªôi dung issue';
}

// Toggle preview visibility
function togglePreview() {
  const previewSection = document.getElementById('previewSection');
  if (previewSection.style.display === 'none' || !previewSection.style.display) {
    showPreview();
  } else {
    hidePreview();
  }
}

// Copy content to clipboard
function copyToClipboard(elementId, button) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  const text = element.textContent;
  
  // Use the Clipboard API if available
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => {
      showCopyFeedback(button);
    }).catch(err => {
      console.error('Failed to copy: ', err);
      fallbackCopy(text, button);
    });
  } else {
    fallbackCopy(text, button);
  }
}

// Show copy success feedback
function showCopyFeedback(element) {
  // Add copying class for smooth animation
  element.classList.add('copying');
  
  // Store original text
  const originalText = element.textContent;
  
  // Show success message
  const fieldName = originalText.split(':')[0];
  element.textContent = `${fieldName}: ‚úì ƒê√£ copy!`;
  
  // Reset after animation
  setTimeout(() => {
    element.textContent = originalText;
    element.classList.remove('copying');
  }, 1500);
}

// Fallback copy method for older browsers
function fallbackCopy(text, button) {
  const textArea = document.createElement('textarea');
  textArea.value = text;
  textArea.style.position = 'fixed';
  textArea.style.opacity = '0';
  document.body.appendChild(textArea);
  textArea.select();
  
  try {
    document.execCommand('copy');
    showCopyFeedback(button);
  } catch (err) {
    console.error('Fallback copy failed: ', err);
  }
  
  document.body.removeChild(textArea);
}

// T·∫°o display text cho vulnerability
function createVulnerabilityDisplayText(vuln) {
  let path = vuln.category;
  if (vuln.subcategory) {
    path += '/' + vuln.subcategory;
  }
  if (vuln.variant) {
    path += '/' + vuln.variant;
  }
  return {
    path: path,
    name: vuln.name
  };
}

// Hi·ªÉn th·ªã dropdown list v·ªõi hierarchy
function showDropdownList(filteredVulns) {
  const dropdownList = document.getElementById('dropdownList');
  dropdownList.innerHTML = '';
  
  if (filteredVulns.length === 0) {
    dropdownList.style.display = 'none';
    return;
  }
  
  // Nh√≥m vulnerabilities theo hierarchy
  const grouped = {};
  
  filteredVulns.forEach((vuln, index) => {
    const category = vuln.category || 'Other';
    const subcategory = vuln.subcategory || '';
    const variant = vuln.variant || '';
    
    if (!grouped[category]) {
      grouped[category] = {};
    }
    
    if (!grouped[category][subcategory]) {
      grouped[category][subcategory] = {};
    }
    
    if (!grouped[category][subcategory][variant]) {
      grouped[category][subcategory][variant] = [];
    }
    
    grouped[category][subcategory][variant].push({
      vuln: vuln,
      originalIndex: index
    });
  });
  
  // Render hierarchy
  Object.keys(grouped).sort().forEach(category => {
    // Category header
    const categoryItem = document.createElement('div');
    categoryItem.className = 'dropdown-category';
    categoryItem.textContent = category;
    dropdownList.appendChild(categoryItem);
    
    Object.keys(grouped[category]).sort().forEach(subcategory => {
      if (subcategory) {
        // Subcategory header
        const subcategoryItem = document.createElement('div');
        subcategoryItem.className = 'dropdown-subcategory';
        subcategoryItem.textContent = subcategory;
        dropdownList.appendChild(subcategoryItem);
      }
      
      Object.keys(grouped[category][subcategory]).sort().forEach(variant => {
        if (variant) {
          // Variant header
          const variantItem = document.createElement('div');
          variantItem.className = 'dropdown-variant';
          variantItem.textContent = variant;
          dropdownList.appendChild(variantItem);
        }
        
        // Vulnerability items
        grouped[category][subcategory][variant].forEach(item => {
          const vulnItem = document.createElement('div');
          vulnItem.className = 'dropdown-item';
          vulnItem.dataset.index = item.originalIndex;
          
          let indentClass = 'dropdown-item';
          if (variant) {
            indentClass += ' indent-3';
          } else if (subcategory) {
            indentClass += ' indent-2';
          } else {
            indentClass += ' indent-1';
          }
          vulnItem.className = indentClass;
          
          vulnItem.innerHTML = `<div class="vulnerability-name">${item.vuln.name}</div>`;
          
          vulnItem.addEventListener('click', () => {
            selectVulnerability(item.vuln);
          });
          
          dropdownList.appendChild(vulnItem);
        });
      });
    });
  });
  
  dropdownList.style.display = 'block';
}

// Ch·ªçn vulnerability
function selectVulnerability(vuln) {
  selectedVulnerability = vuln;
  const display = createVulnerabilityDisplayText(vuln);
  const input = document.getElementById('vulnerabilitySelect');
  input.value = `${display.path} - ${display.name}`;
  
  // ·∫®n dropdown
  document.getElementById('dropdownList').style.display = 'none';
  
  // C·∫≠p nh·∫≠t preview
  updatePreview(vuln);
}

// Filter vulnerabilities theo search term
function filterVulnerabilities(searchTerm) {
  let filtered;
  
  if (!searchTerm.trim()) {
    filtered = vulnerabilities.slice(); // L·∫•y t·∫•t c·∫£ items
  } else {
    const term = searchTerm.toLowerCase();
    filtered = vulnerabilities.filter(vuln => {
      return (vuln.category && vuln.category.toLowerCase().includes(term)) ||
             (vuln.subcategory && vuln.subcategory.toLowerCase().includes(term)) ||
             (vuln.variant && vuln.variant.toLowerCase().includes(term)) ||
             (vuln.name && vuln.name.toLowerCase().includes(term));
    });
  }
  
  // Sort theo category, subcategory, variant, name
  filtered.sort((a, b) => {
    // So s√°nh category tr∆∞·ªõc
    const categoryCompare = (a.category || '').localeCompare(b.category || '');
    if (categoryCompare !== 0) return categoryCompare;
    
    // N·∫øu category gi·ªëng nhau, so s√°nh subcategory
    const aSubcategory = a.subcategory || '';
    const bSubcategory = b.subcategory || '';
    const subcategoryCompare = aSubcategory.localeCompare(bSubcategory);
    if (subcategoryCompare !== 0) return subcategoryCompare;
    
    // N·∫øu subcategory gi·ªëng nhau, so s√°nh variant
    const aVariant = a.variant || '';
    const bVariant = b.variant || '';
    const variantCompare = aVariant.localeCompare(bVariant);
    if (variantCompare !== 0) return variantCompare;
    
    // Cu·ªëi c√πng so s√°nh name
    return (a.name || '').localeCompare(b.name || '');
  });
  
  return filtered.slice(0, 50); // Gi·ªõi h·∫°n 20 k·∫øt qu·∫£
}

// H√†m ƒë·ªÉ l·∫•y tab hi·ªán t·∫°i
async function getCurrentTab() {
  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  return tab;
}

// H√†m ƒë·ªÉ tr√≠ch xu·∫•t ID d·ª± √°n t·ª´ URL
function extractProjectId(url) {
  try {
    const match = url.match(/https:\/\/pentest\.viettelcyber\.com\/#\/projects\/(\d+)/);
    if (match && match[1]) {
      return match[1];
    }
  } catch (e) {
    console.error("Kh√¥ng th·ªÉ ph√¢n t√≠ch URL:", e);
  }
  return null;
}

// H√†m ƒë·ªÉ l·∫•y token t·ª´ localStorage c·ªßa trang
async function getTokenFromStorage(tabId) {
  try {
    const results = await chrome.scripting.executeScript({
      target: { tabId: tabId },
      func: () => {
        return localStorage.getItem('token');
      }
    });
    if (results && results[0]) {
      return results[0].result;
    }
  } catch (e) {
    console.error("Kh√¥ng th·ªÉ l·∫•y token:", e);
    return null;
  }
}

// H√†m ƒë·ªÉ l·∫•y refresh token t·ª´ localStorage c·ªßa trang
async function getRefreshTokenFromStorage(tabId) {
  try {
    const results = await chrome.scripting.executeScript({
      target: { tabId: tabId },
      func: () => {
        return localStorage.getItem('refresh-token');
      }
    });
    if (results && results[0]) {
      return results[0].result;
    }
  } catch (e) {
    console.error("Kh√¥ng th·ªÉ l·∫•y refresh token:", e);
    return null;
  }
}

// H√†m ƒë·ªÉ c·∫≠p nh·∫≠t token trong localStorage c·ªßa trang
async function updateTokenInStorage(tabId, newToken) {
  try {
    const results = await chrome.scripting.executeScript({
      target: { tabId: tabId },
      func: (token) => {
        localStorage.setItem('token', token);
        return true;
      },
      args: [newToken]
    });
    return results && results[0] && results[0].result;
  } catch (e) {
    console.error("Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t token:", e);
    return false;
  }
}

// H√†m ƒë·ªÉ refresh token
async function refreshToken(tabId) {
  try {
    updateStatus('ƒêang l√†m m·ªõi token...');
    
    const refreshTokenValue = await getRefreshTokenFromStorage(tabId);
    if (!refreshTokenValue) {
      throw new Error('Kh√¥ng t√¨m th·∫•y refresh token');
    }

    const response = await fetch('https://pentest.viettelcyber.com/api/v1/token/refresh', {
      method: 'POST',
      headers: {
        'accept': 'application/json',
        'accept-language': 'vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7',
        'content-type': 'application/json',
        'origin': 'https://pentest.viettelcyber.com',
        'priority': 'u=1, i',
        'referer': 'https://pentest.viettelcyber.com/',
        'sec-ch-ua': '"Google Chrome";v="141", "Not?A_Brand";v="8", "Chromium";v="141"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-origin',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36'
      },
      body: JSON.stringify({
        token: refreshTokenValue
      })
    });

    if (!response.ok) {
      throw new Error(`L·ªói refresh token: ${response.status}`);
    }

    const result = await response.json();
    
    if (!result.token) {
      throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c token m·ªõi t·ª´ API refresh');
    }

    // C·∫≠p nh·∫≠t token m·ªõi v√†o localStorage
    const updated = await updateTokenInStorage(tabId, result.token);
    if (!updated) {
      throw new Error('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t token m·ªõi v√†o localStorage');
    }

    updateStatus('Token ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi th√†nh c√¥ng');
    return result.token;

  } catch (error) {
    console.error('L·ªói khi refresh token:', error);
    updateStatus(`L·ªói refresh token: ${error.message}`);
    throw error;
  }
}

// Helper function to make API request with proper headers and retry logic
async function makeApiRequest(url, options, tabId, retryCount = 0) {
  const maxRetries = 1;
  
  try {
    // L·∫•y token hi·ªán t·∫°i
    const token = await getTokenFromStorage(tabId);
    if (!token) {
      await refreshToken(tabId);
      return await makeApiRequest(url, options, tabId, retryCount + 1);
    }

    // Prepare headers
    const headers = {
      'accept': 'application/json',
      'accept-language': 'vi,en-US;q=0.9,en;q=0.8',
      'content-type': 'application/json',
      'priority': 'u=1, i',
      'sec-ch-ua': '"Chromium";v="142", "Google Chrome";v="142", "Not_A Brand";v="99"',
      'sec-ch-ua-mobile': '?0',
      'sec-ch-ua-platform': '"Windows"',
      'sec-fetch-dest': 'empty',
      'sec-fetch-mode': 'cors',
      'sec-fetch-site': 'same-origin',
      'token': token,
      ...options.headers
    };

    // G·ª≠i request
    const response = await fetch(url, {
      ...options,
      headers,
      referrer: 'https://pentest.viettelcyber.com/',
      mode: 'cors',
      credentials: 'omit'
    });

    // N·∫øu 401 v√† ch∆∞a th·ª≠ l·∫°i, refresh token v√† ƒë·ªá quy
    if (response.status === 401 && retryCount < maxRetries) {
      updateStatus('Token h·∫øt h·∫°n, ƒëang l√†m m·ªõi...');
      
      // Refresh token
      await refreshToken(tabId);
      
      // ƒê·ªá quy g·ªçi l·∫°i v·ªõi retryCount tƒÉng
      updateStatus('ƒêang g·ª≠i request v·ªõi token m·ªõi...');
      return await makeApiRequest(url, options, tabId, retryCount + 1);
    }

    // N·∫øu v·∫´n 401 sau khi th·ª≠ l·∫°i
    if (response.status === 401) {
      throw new Error('Token m·ªõi v·∫´n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
    }

    // Ki·ªÉm tra c√°c l·ªói HTTP kh√°c
    if (!response.ok) {
      throw new Error(`L·ªói HTTP: ${response.status}`);
    }

    return await response.json();

  } catch (error) {
    // N·∫øu l√† l·ªói network v√† ch∆∞a th·ª≠ l·∫°i, c√≥ th·ªÉ th·ª≠ l·∫°i
    if (retryCount < maxRetries && (error.message.includes('fetch') || error.message.includes('network'))) {
      updateStatus('L·ªói k·∫øt n·ªëi, ƒëang th·ª≠ l·∫°i...');
      return await makeApiRequest(url, options, tabId, retryCount + 1);
    }
    
    throw error;
  }
}

// H√†m t·∫°o issue v·ªõi 2 b∆∞·ªõc: POST ƒë·ªÉ t·∫°o v√† PUT ƒë·ªÉ c·∫≠p nh·∫≠t
async function createIssueWithTwoSteps(tabId, projectId, vulnerabilityData) {
  try {
    updateStatus('ƒêang t·∫°o issue...');
    
    // B∆∞·ªõc 1: POST ƒë·ªÉ t·∫°o issue v·ªõi content tr·ªëng
    const createData = {
      projectId: parseInt(projectId, 10),
      category: vulnerabilityData.category,
      subcategory: vulnerabilityData.subcategory || null,
      variant: vulnerabilityData.variant || null,
      severity: "VARIES",
      cvss: "",
      content: [{
        name: "UNNAMED",
        language: "VIETNAM",
        description: "",
        reproduce: "",
        solution: ""
      }]
    };

    const createResponse = await makeApiRequest(
      'https://pentest.viettelcyber.com/api/issue',
      {
        method: 'POST',
        body: JSON.stringify(createData)
      },
      tabId
    );

    if (!createResponse || !createResponse.id) {
      throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ID issue t·ª´ server');
    }

    const issueId = createResponse.id;
    updateStatus('Issue ƒë√£ t·∫°o, ƒëang c·∫≠p nh·∫≠t n·ªôi dung...');

    // B∆∞·ªõc 2: G·ª≠i nhi·ªÅu PUT request song song cho t·ª´ng field
    const fieldsToUpdate = [
      { name: vulnerabilityData.name || "UNNAMED", language: "VIETNAM" },
      { description: vulnerabilityData.desc || vulnerabilityData.description || "", language: "VIETNAM" },
      { impact: vulnerabilityData.impact || "", language: "VIETNAM" },
      { reproduce: vulnerabilityData.reprod || vulnerabilityData.reproduce || "", language: "VIETNAM" },
      { solution: vulnerabilityData.solution || "", language: "VIETNAM" },
      { note: vulnerabilityData.note || "", language: "VIETNAM" }
    ];

    // G·ª≠i t·∫•t c·∫£ PUT request song song
    const updatePromises = fieldsToUpdate.map(fieldData => 
      makeApiRequest(
        `https://pentest.viettelcyber.com/api/issue/${issueId}`,
        {
          method: 'PUT',
          body: JSON.stringify(fieldData)
        },
        tabId
      )
    );

    // ƒê·ª£i t·∫•t c·∫£ request ho√†n th√†nh
    await Promise.all(updatePromises);

    updateStatus('Issue ƒë√£ ƒë∆∞·ª£c t·∫°o v√† c·∫≠p nh·∫≠t th√†nh c√¥ng!');
    return createResponse;

  } catch (error) {
    console.error('L·ªói khi t·∫°o issue:', error);
    throw error;
  }
}

// X·ª≠ l√Ω nh·∫•p chu·ªôt v√†o n√∫t
document.getElementById('sendRequestBtn').addEventListener('click', async () => {
  const button = document.getElementById('sendRequestBtn');
  
  // Ki·ªÉm tra xem ƒë√£ ch·ªçn vulnerability ch∆∞a
  if (!selectedVulnerability) {
    updateStatus('Vui l√≤ng ch·ªçn lo·∫°i l·ªói tr∆∞·ªõc khi t·∫°o issue.');
    return;
  }
  
  button.disabled = true;
  updateStatus('ƒêang x·ª≠ l√Ω...');

  const tab = await getCurrentTab();

  if (!tab || !tab.url || !tab.id) {
    updateStatus('L·ªói: Kh√¥ng t√¨m th·∫•y tab ho·∫°t ƒë·ªông.');
    button.disabled = false;
    return;
  }

  // 1. L·∫•y Project ID t·ª´ URL
  const projectId = extractProjectId(tab.url);
  if (!projectId) {
    updateStatus('L·ªói: Kh√¥ng t√¨m th·∫•y Project ID trong URL.');
    button.disabled = false;
    return;
  }

  // 2. L·∫•y Token t·ª´ Local Storage
  let token = await getTokenFromStorage(tab.id);
  if (!token) {
    updateStatus('L·ªói: Kh√¥ng t√¨m th·∫•y token trong localStorage.');
    await refreshToken(tab.id);
  }

  try {
    // G·ª≠i request v·ªõi 2 b∆∞·ªõc: t·∫°o issue r·ªìi c·∫≠p nh·∫≠t n·ªôi dung
    const result = await createIssueWithTwoSteps(tab.id, projectId, selectedVulnerability);
    
    updateStatus('Th√†nh c√¥ng! ƒêang chuy·ªÉn h∆∞·ªõng...');
    console.log('Ph·∫£n h·ªìi API:', result);

    // L·∫•y issueId t·ª´ response v√† redirect
    if (result && result.id) {
      const issueId = result.id;
      const redirectUrl = `https://pentest.viettelcyber.com/#/projects/${projectId}/issues/${issueId}`;
      
      // Redirect tab hi·ªán t·∫°i ƒë·∫øn URL m·ªõi
      await chrome.tabs.update(tab.id, { url: redirectUrl });
      
      // ƒê√≥ng popup sau khi redirect
      window.close();
    }

  } catch (error) {
    console.log('L·ªói khi g·ª≠i y√™u c·∫ßu:', error);
    updateStatus(`L·ªói: ${error.message}`);
  } finally {
    button.disabled = false;
  }
});

// Kh·ªüi t·∫°o khi DOM ƒë∆∞·ª£c load
document.addEventListener('DOMContentLoaded', async () => {
  // Load d·ªØ li·ªáu t·ª´ Cloudflare Host khi kh·ªüi ƒë·ªông
  const success = await loadVulnerabilities();
  
  const input = document.getElementById('vulnerabilitySelect');
  const dropdownList = document.getElementById('dropdownList');
  const refreshBtn = document.getElementById('refreshDataBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const previewToggle = document.getElementById('previewToggle');
  const modal = document.getElementById('keyModal');
  const saveKeyBtn = document.getElementById('saveKeyBtn');
  const cancelKeyBtn = document.getElementById('cancelKeyBtn');
  const hostUrlInput = document.getElementById('hostUrlInput');
  
  // X·ª≠ l√Ω preview toggle
  previewToggle.addEventListener('click', () => {
    togglePreview();
  });
  
  // X·ª≠ l√Ω copy buttons v·ªõi event delegation
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('copy-btn') || e.target.hasAttribute('data-target')) {
      const targetId = e.target.getAttribute('data-target');
      if (targetId) {
        copyToClipboard(targetId, e.target);
      }
    }
  });
  
  // N·∫øu kh√¥ng load ƒë∆∞·ª£c d·ªØ li·ªáu, hi·ªÉn th·ªã modal
  if (!success) {
    showKeyModal();
  }
  
  // X·ª≠ l√Ω button settings
  settingsBtn.addEventListener('click', () => {
    showKeyModal();
  });
  
  // X·ª≠ l√Ω modal l∆∞u Host URL
  saveKeyBtn.addEventListener('click', async () => {
    const hostUrl = hostUrlInput.value.trim() || DEFAULT_HOST_URL;

    saveKeyBtn.disabled = true;
    saveKeyBtn.textContent = 'ƒêang l∆∞u...';

    // L∆∞u config
    const saved = await saveConfig(hostUrl);
    if (!saved) {
      updateStatus('L·ªói khi l∆∞u c·∫•u h√¨nh');
      saveKeyBtn.disabled = false;
      saveKeyBtn.textContent = 'L∆∞u';
      return;
    }

    // Test connection
    const testSuccess = await loadVulnerabilities(true);

    saveKeyBtn.disabled = false;
    saveKeyBtn.textContent = 'L∆∞u';

    if (testSuccess) {
      hideKeyModal();
      // Clear dropdown v√† input
      input.value = '';
      selectedVulnerability = null;
      dropdownList.style.display = 'none';
    }
  });
  
  cancelKeyBtn.addEventListener('click', () => {
    hideKeyModal();
  });
  
  // ƒê√≥ng modal khi click outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      hideKeyModal();
    }
  });
  
  
  hostUrlInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      saveKeyBtn.click();
    }
  });
  
  // X·ª≠ l√Ω button refresh
  refreshBtn.addEventListener('click', async () => {
    refreshBtn.disabled = true;
    refreshBtn.textContent = 'üîÑ ƒêang t·∫£i...';
    
    const success = await loadVulnerabilities(true);
    
    refreshBtn.disabled = false;
    refreshBtn.textContent = 'üîÑ';
    
    // Clear dropdown v√† input n·∫øu load th√†nh c√¥ng
    if (success) {
      input.value = '';
      selectedVulnerability = null;
      dropdownList.style.display = 'none';
    }
  });
  
  // X·ª≠ l√Ω focus v√†o input
  input.addEventListener('focus', () => {
    const filtered = filterVulnerabilities(input.value);
    showDropdownList(filtered);
  });
  
  // X·ª≠ l√Ω input search
  input.addEventListener('input', (e) => {
    const searchTerm = e.target.value;
    const filtered = filterVulnerabilities(searchTerm);
    showDropdownList(filtered);
  });
  
  // X·ª≠ l√Ω click outside ƒë·ªÉ ·∫©n dropdown
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown-container')) {
      dropdownList.style.display = 'none';
    }
  });
  
  // X·ª≠ l√Ω keyboard navigation
  input.addEventListener('keydown', (e) => {
    // Ch·ªâ l·∫•y c√°c dropdown-item th·ª±c s·ª± (c√≥ dataset.index), kh√¥ng l·∫•y headers
    const items = dropdownList.querySelectorAll('.dropdown-item[data-index]');
    let selectedIndex = Array.from(items).findIndex(item => item.classList.contains('selected'));
    
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        if (selectedIndex < items.length - 1) {
          if (selectedIndex >= 0) items[selectedIndex].classList.remove('selected');
          items[selectedIndex + 1].classList.add('selected');
        } else if (items.length > 0) {
          if (selectedIndex >= 0) items[selectedIndex].classList.remove('selected');
          items[0].classList.add('selected');
        }
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        if (selectedIndex > 0) {
          items[selectedIndex].classList.remove('selected');
          items[selectedIndex - 1].classList.add('selected');
        } else if (items.length > 0) {
          if (selectedIndex >= 0) items[selectedIndex].classList.remove('selected');
          items[items.length - 1].classList.add('selected');
        }
        break;
        
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && items[selectedIndex]) {
          const vulnIndex = parseInt(items[selectedIndex].dataset.index);
          const filtered = filterVulnerabilities(input.value);
          if (filtered[vulnIndex]) {
            selectVulnerability(filtered[vulnIndex]);
          }
        }
        break;
        
      case 'Escape':
        dropdownList.style.display = 'none';
        input.blur();
        break;
    }
  });
});
